1.  大屏用的技术
2.  大屏数据来源与管理
3.  http缓存
4.  做过的有特点的项目
5.  遇到的问题与解决方案
6.  前端安全相关(着重中间人劫持)
7.  为什么跳槽
8.  职业规划
9.  项目开发流程
10. 对vuex的看法
11. vue从data改变到页面渲染的过程
12. 介绍状态机
13. 组件设计原则
14. 怎么看待组件层级嵌套很多层
15. 前端安全防范措施
16. 对http2的了解
17. websocket的使用场景
18. pwa的使用
19. 对新技术的了解




https://www.cnblogs.com/DCL1314/p/7903102.html html
一、 css布局
     一、css常见布局
	二、 html常识：
		1. XHTML元素必须被正确地嵌套。
          2. 语义化的html的理解：  1. 便于开发者阅读和规范开发，不同标签有不同的作用
                                 2. 让页面结构化，利于搜索引擎seo，解析
二、 h5
     1. 新增标签：
	      1. 用于媒介回放的video和audio元素
		  2. <bdo dir="rtl|ltr">  规定文字的排列方向
     2. 本地离线存储localStorage长期存储数据
     3. sessionStorage的数据在浏览器关闭后自动删除
     3. 语意化更好的内容元素，比如article,footer,header,nav,section
     4. 表单属性：calendar,date,time,email,url,search
     5. 新的技术webworker,websockt,Geolocation:
        1, webworker: 
		2. 离线缓存：<html manifest='demo.appcache'>    // demo.appcache   =>     CACHE MANIFEST
		                                                                          # 2019-02-01
																				  /home.html
																				  /bg.png
																				  NETWORK:   需要请求的文件
																				  FALLBACK:  请求的URL 可替代的资源
	    3. webSQL：openDatabase transaction executeSql
        4. webworker: 
                          new Webwork(demo.js).onmessage(event){console.log(event.data)}
                          //  在demo.js中直接用postMessge(消息)					
        5. websocket: 单个 TCP 连接上进行全双工通讯的协议。 浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
                         ws = new WebSocket()
                         ws.onopen
                         ws.onmessage
                         ws.close	  						 
     6. cookie的使用   

三、 js， es6
       一、es6：
	        1. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
			2. 保证在不同环境this指向： // 方法一
                                         var _this =  (typeof window !== 'undefined'
                                             ? window
                                             : (typeof process === 'object' &&
                                                typeof require === 'function' &&
                                                typeof global === 'object')
                                               ? global
                                               : this);
			3. let [x = 1] = [null]; (x=null) // 默认会匹配undefined，当null！==undefined 时，就会被赋值
			   let [x = 1] = []; (x=1)
			4. 对象解构，需注意不是深拷贝，更改某个对象属性值，原对象属性值会发生改变
			5. for of可以遍历字符串、map
			6. '123'.repeat(2)  =>  123123
			7. padStart(/*字符串总长度*/, /*指定需补的字符串*/)，padEnd()  // 字符串长度不够，自动用指定字符串补全
			8. new RegExp(/abc/ig, 'i').flags    //  指定的修饰符‘i’, 将会覆盖以前的‘ig’
			9.正则中可以利用lastIndex属性来指定从何处开始匹配  /a/.lastIndex
			10. Number.MIN_SAFE_INTEGER检查最大安全整数（-2^53 +1）
			11. Math.trunc()  // 用于去除一个数的小数部分，  内部会使用Number方法将其先转为数值
			12. 指数运算符  2**3， 采用的是右结合 
            13. 箭头函数不适宜定义在一个对象中，  还有不适宜 给一个dom对象添加监听函数的回调中
            14. 函数参数可以有默认值
            15. 用扩展运算符合并数组时，是一种浅拷贝，使用时需注意.  用扩展运算符...和concat复制数组却不会(如果数组里有对象，也只是浅拷贝)	
			16. Array.from方法把类数组（Set也可）对象和可遍历对象， 可以有第二个参数，相当于map
            17. Array.of方法用于将一组值，转换为数组。Array.of(3, 11, 8) // [3,11,8]    new Array(3).fill(7) // [7,7,7]
			18. Array.prototype.flat()用于将嵌套的数组“拉平”
          var arr = [1, [[2, 3], 4], [5, 6]];
          var flat = function* (a) {    //  利用Generator函数将数组拉平
             for (var i = 0; i < a.length; i++){
             if (typeof a[i] !== 'number') {
                yield* flat(a[i]);
             } else {
                yield a[i];
             }
          });
          };
          for (var f of flat(arr)){
             console.log(f);
          }
			19. Object.getOwnPropertyNames(obj)  // 获取自身所有属性，（不包含symbol,但包含不可枚举属性）
			20. Reflect.ownKeys(obj) // 获取自身所有属性，（包含symbol,包含不可枚举属性）
			21. Object.assign({}, a);上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。
                        // 写法一
                        const clone1 = {
                          __proto__: Object.getPrototypeOf(obj),
                          ...obj
                        };
                        
                        // 写法二
                        const clone2 = Object.assign(
                          Object.create(Object.getPrototypeOf(obj)),
                          obj
                        );
                        
                        // 写法三
                        const clone3 = Object.create(
                          Object.getPrototypeOf(obj),
                          Object.getOwnPropertyDescriptors(obj)
                        )
			22. Object.is(NaN, NaN) => true  // 可以判断两个对象是否相等, Object.is(+0, -0) // false   +0 === -0 // ture
                let obj = {a: 1};
                Object.assign(obj, undefined) === obj // true   // null和undefined为第一个参数的话则会报错
                Object.assign(obj, null) === obj // true
                Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
				             属性名为 Symbol 值的属性，也会被Object.assign拷贝。是一种浅拷贝，只能对一些简单对象进行拷贝，对象里面有对象，得到的只是里面对象的应用
                使用for...in循环和Object.getOwnPropertyNames()方法都得不到 Symbol 键名，需要使用Object.getOwnPropertySymbols()方法。
            23. Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。
            24.	Symbol.for("bar") === Symbol.for("bar") =》true	// 但是此方法登记的值，是全局注册的，不管在什么地方声明
			25. Set遍历的时候键与值相等
			26. forEach、map方法还可以有第二个参数，表示绑定处理函数内部的this对象。 [].map(function(item){console.log(this)  //  this ==> {a: 1}
			                                                                                               }, {a: 1})
			27. 扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。																						   
			28. WeakSet 的成员只能是对象，而不能是其他类型的值。new WeakSet({})   WeakMap类似
			29. 对象只接受字符串作为键名， 当用一个dom节点作为键名时，会被转化为‘[object HTMLDivElement]’
			30. map的键可以为任意的类型的值， 和set 一样，当键为对象时， 键只是对象的引用地址
			31. proxy对象： var obj = new Proxy({}, {
                                  get: function (target, propKey, receiver) {
                                    console.log(`getting ${propKey}!`);
                                    return Reflect.get(target, propKey, receiver);
                                  },
                                  set: function (target, propKey, value, receiver) {
                                    console.log(`setting ${propKey}!`);
                                    return Reflect.set(target, propKey, value, receiver);
                                  }
                                });
      32. 具有的iterator接口的对象才可以进行for of 遍历， obj = {  [Symbol.iteroter]() {   return {  next() { {done: , value: } }}}}   //   这样的话obj也能进行for of遍历了， 必须有next方法
          对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。
      33. Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态，。  
          调用 Generator 函数返回的只是内部状态的一个指针，调用next方法才能得到里面的状态 ， 只有当调用next才会去执行yeild后面的表达式，只有调用next方法，函数才会开始执行
          yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 console.log('Hello' + (yield 123)); // OK
          yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。let input = yield; // OK
			    yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
        	Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。
          如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。
          throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。
          throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。
<<<<<<< Updated upstream
          ，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。且没有被内部捕获，就不会再执行下去了
          Generator 函数也不能跟new命令一起用，会报错
=======
          ，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。
>>>>>>> Stashed changes
			         
四、 vue
       一、vue3.0 的响应式：  proxy 不会去污染原对象
	         <script src="./dist/reactivity.global.js"></script>
             <script>
             const { reactive, effect } = VueObserver
             const origin = {
               count: 0
             }
             const state = reactive(origin)  //  利用reactive把origin用Proxy包裹
             const fn = () => {
               const count = state.count
               console.log(`set count to ${count}`)
             }
             effect(fn)  // 使用 effect() 函数把 fn() 作为响应式回调。当 state.count 发生变化时，便触发了 fn()
			             // 由于在 fn() 里面有引用到 Proxy 对象的属性，所以这一步会触发对象的 getter，从而启动依赖收集。
						 // 当一个函数fn()被effect()包裹后，就会变成一个响应式的effect函数， 而且 fn()函数也会被立即执行一次
             </script>

	   二、vue2.0的响应式：
	         1. Object.defineProperty() // 最初设计是用来给对象的属性设置权限的
			 2. Object.frezee()  //  不可写、可枚举、不可配置
			 3. Object.seal()    //   可写、可枚举、不可配置
			 4. 响应式的依赖收集发生在get里， 在set里触发视图更新
			 5. 对数组的响应式，利用装饰者模式，拷贝一份原数组方法,
			 
	   三、 new Vue()到底做了什么？
             1. new Vue首先调用init()方法、
			   在init方法里会进行一系列初始化操作：
			    initLifecycle(vm)、// 初始化$parent $root $children 建立父子组件关系，在当前实例上添加一些属性和生命周期标识
				initEvents(vm)、initRender(vm)、callHook(vm, 'beforeCreate')
			    initInjections(vm) // 对inject的数据进行响应式的监听
				initState(vm)   // 初始化props methods data 
				initProvide(vm) callHook(vm, 'create')、 最后判断option选项是否有el，如有vm.$mount(vm.$options.el)
			 2. 会依次执行  initMixin(Vue);
                            stateMixin(Vue);
                            eventsMixin(Vue);
                            lifecycleMixin(Vue);
                            renderMixin(Vue);	
							
	   四、keep-alive: 参考地址：https://www.jianshu.com/p/0b0222954483
	       1.keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
	          两个属性： include - 字符串或正则表达，只有匹配的组件会被缓存、exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存
            <keep-alive>
                <router-view>
                <!-- 所有路径匹配到的视图组件都会被缓存！ -->
            </router-view>
			2. 缺点：需要知道组件的 name，项目复杂的时候不是很好的选择
			3. <router-view v-if="!$route.meta.keepAlive">   //    router列表项加meta属性： meta: {keepAlive: true}
                 <!-- 这里是不被缓存的视图组件，比如 Edit！ -->
               </router-view>
               </keep-alive>
			4. 可以利用组件内         beforeRouteLeave(to, from, next) { //  提醒需要 ： router列表项加meta属性： meta: {keepAlive: true}
                                            // 设置下一个路由的 meta
                                           to.meta.keepAlive = false; // 让 A 不缓存，即刷新
                                             next();
                                      }
			5. 涉及到的生命周期： activated  deactivated	
        五、 路由模式： hash 默认浏览器  history  需要h5 history API支持  abstract nodejs环境（JavaScript运行所在的环境）
        六、  serverPrefetch前身是 ssrPrefetch。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。
        七、 vue.observable
   
五、 http
     一、 XMLHttpRequest
	 二、 跨域: CROS
                JSONP
	 三、 http2：
	      1. 在http2里面，我们很容易可以看到10个甚至100个同时并存的流。创建一个新的流的代价也非常低。
             它允许多个并发 HTTP 请求共用一个 TCP会话，而不是为每个请求单独开放连接，这样只需建立一个 TCP 连接就可以传送网页上所有资源，
		     不仅可以减少消息交互往返的时间还可以避免创建新连接造成的延迟，使得 TCP 的效率更高。
          2. 对于相同的数据，不必每次携带相同的头信息，如果请求中不包含首部，此时所有首部都自动使用之前请求发送的首部		  

六、 安全：https://mp.weixin.qq.com/s/mI859obHtYoj9OH9jS780g
       一、常见几种攻击方式：
	       1. SQL注入：  'select * from user where id='当浏览器传一个id为true时，这就会查询所有
		   2. XSS：  XSS 全称是跨站脚本攻击。通过代码注入的方式来达到攻击的目的。例如： 输入这样的文本<script>alert(1)</script>, 有的浏览器会自动执行
		         有两种方式可以防御：
                 1. 字符转译
                 2. CSP(Content Security Policy)：  设置 HTTP Header 中的 Content-Security-Policy
		   3. CSRF： CSRF  全称是跨站请求伪造( Cross Site Request Forgery)，本质上， 说白了就是借用用户的身份或权限偷偷的完成某些操作。
                     CSRF 的发生其实是借助了 cookie 的特性。
					 我们登录了某个 http://tao.com 购物网站之后，cookie 就会有登录过的标记了。此时请求http://tao.com/pay?id=123&money=1000，
					 是会带着 cookie 的，server 端就知道已经登录了。如果在http://tao.com去请求其他域名的 API ,  例如http://tx.com/api时，
					 是不会带 cookie 的，这是浏览器同源策略的限制。但是此时在其他域名的页面中，请求http://tao.com/pay?id=123&money=1000，
					 就会带着tao.com的 cookie 。这是发生 CSRF 攻击的理论基础。
					 	 防御： 防御CSRF 有效的手段就是加入各个层级的权限验证.
                            例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者扫码验证才行。
                            除此之外，敏感的接口要使用POST请求而不是GET.

		   4. 点击劫持： 也被称为UI-覆盖攻击，攻击方式就是在某些操作的按钮上加一层透明的iframe。
		           防御方法： 1. 使用 HTTP 头防御
				                    通过配置 nginx 发送 X-Frame-Options 响应头，这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
									这样浏览器就会阻止嵌入网页的渲染。该响应头有三个值可选，分别是：
									                                                        DENY，表示页面不允许通过 iframe 的方式展示。
																							SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示。
							  2. 使用 Javascript 防御
							        判断顶层视口的域名是不是和本页面的域名一致，如果不一致就让恶意网页自动跳转到我方的网页。																ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示。
    
		   5. 中间人劫持：中间人攻击（Man-in-the-Middle Attack, MITM）
		                  简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探来达到攻击的目的，而通信的双方却毫不知情。
						  建议： 
                          以下是针对防止中间人攻击的一些建议：
                             确保当前你所访问的网站使用了HTTPS
                             如果你是一个网站管理员，你应当执行HSTS协议
                             不要在公共Wi-Fi上发送敏感数据
                             如果你的网站使用了SSL，确保你禁用了不安全的SSL/TLS协议。
                             不要点击恶意链接或电子邮件。

七、 新技术   
             1. webassembly
			 2. flutter
			 3. sticky
			 4. webp
			 5. web bundles api 离线分发web内容

八、 算法
九、 项目:   鉴权、
             首屏渲染：为了seo优化和首屏渲染速度、（纯客户端程序，需要加载各种js来渲染页面，因而不利于seo优化）
			   1.  ssr(srever side render):
			       1. 	特点： 每次访问都必须新建一个vue实例，只会触发beforeCreate和created函数， 其他就需要客户端的js
				               每次在服务端只是生成html字符串，然后在客户端触发mounted，挂载到页面上
				   2.   安装vue-server-renderer ;
				           用法： const render = require('vue-server-render').createRenderer()
						          render.renderToString(app /* vue 实例 */).then(html=> {
								  
								  })
						参考地址：https://zhuanlan.zhihu.com/p/41427873		  
				   3.  浏览器环境才能执行的函数对象，不要在服务端中运行（即不要出现在beforecreate和created函数中）	
                   4.  路由一定是采用history模式，因为hash模式的路由提交不到服务器	
                   5.  官方方案使用Vuex在服务端预获取数据。 在服务端添加vue钩子函数asyncData，获取数据后，将数据保存在vuex的store结构中，同时渲染页面4
                          例子：   asyncData ({ store }) {
                                       //惰性注册store模块
                                          store.registerModule('foo', fooStoreModule)
                                       //执行foo命名空间下名为inc的action操作
                                       return store.dispatch('foo/inc')		
                                   ｝									   
  			 打包优化、
			   1. webpack配置
			   2. dll优化： 先对loadsh、jquery这些不会改变的代码进行webpack打包处理，然后再对其他文件进行打包处理
			             1. dll单独配置（webpack.dll.js）：  import webpack from 'webpack'
                                                             module.exports = {
                                                               entry: {
                                                                 vendor: ['loadsh']
                                                               },
                                                               output: {
                                                                 path: __dirname + '/dll',
                                                                 filename: '[name].dll.js',
                                                                 library: '[name]_library'
                                                               },
                                                               plugins: [
                                                                 new webpack.DllPlugin({
                                                                   path: __dirname + '/dll/[name]-manifest.json',
                                                                   name: '[name]_library'
                                                                 })
                                                               ]
															   }
                          2. webpack配置：plugins: [
						     new webpack.DllReferencePlugin({
                                 manifest: require('../dll/vendor-manifest.json')
                           })
						  ]  
                         3. 在打包后的文件中手动引入 主页面index.html
                         4. 其他文件，正常引入，并使用		
                  3. 严格控制组件内存回收
                  4. webworker并发渲染       				 
													  
			   
			 mock、
			 发布服务：
			    nginx原理
				负载
				安全
				跨域
              问题1: 避免表单重复提交，或按钮重复点击：  1.  设置变量，带请求结束后，更新变量。 2. 自定义指令 3. 重写组件，事情变得麻烦，不可取     
			防止重复提交： （自定义指令）
                       Vue.directive("btn-control", {
                           // 插入dom 时做的事情
                           inserted: function(el, bind) {
                               el.addEventListener("click", () => {
                                   el.disabled = true;
                                   bind.value().then(res => {
                                       el.disabled = false;
                                   });
                               });
                           }	
十、 axios源码、vue-router、 vuex