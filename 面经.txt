1.  大屏用的技术
2.  大屏数据来源与管理
3.  http缓存
4.  做过的有特点的项目
5.  遇到的问题与解决方案
6.  前端安全相关(着重中间人劫持)
7.  为什么跳槽
8.  职业规划
9.  项目开发流程
10. 对vuex的看法
11. vue从data改变到页面渲染的过程
12. 介绍状态机
13. 组件设计原则
14. 怎么看待组件层级嵌套很多层
15. 前端安全防范措施
16. 对http2的了解
17. websocket的使用场景
18. pwa的使用
19. 对新技术的了解




https://www.cnblogs.com/DCL1314/p/7903102.html html
一、 css布局
     一、css常见布局
	二、 html常识：
		1. XHTML元素必须被正确地嵌套。
          2. 语义化的html的理解：  1. 便于开发者阅读和规范开发，不同标签有不同的作用
                                 2. 让页面结构化，利于搜索引擎seo，解析
二、 h5
     1. 新增标签：
	      1. 用于媒介回放的video和audio元素
		  2. <bdo dir="rtl|ltr">  规定文字的排列方向
     2. 本地离线存储localStorage长期存储数据
     3. sessionStorage的数据在浏览器关闭后自动删除
     3. 语意化更好的内容元素，比如article,footer,header,nav,section
     4. 表单属性：calendar,date,time,email,url,search
     5. 新的技术webworker,websockt,Geolocation:
        1, webworker: 
		2. 离线缓存：<html manifest='demo.appcache'>    // demo.appcache   =>     CACHE MANIFEST
		                                                                          # 2019-02-01
																				  /home.html
																				  /bg.png
																				  NETWORK:   需要请求的文件
																				  FALLBACK:  请求的URL 可替代的资源
	    3. webSQL：openDatabase transaction executeSql
        4. webworker: 
                          new Webwork(demo.js).onmessage(event){console.log(event.data)}
                          //  在demo.js中直接用postMessge(消息)					
        5. websocket: 单个 TCP 连接上进行全双工通讯的协议。 浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
                         ws = new WebSocket()
                         ws.onopen
                         ws.onmessage
                         ws.close	  						 
     6. cookie的使用   

三、 js， es6
       一、es6：
	        1. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
			2. 保证在不同环境this指向： // 方法一
                                         var _this =  (typeof window !== 'undefined'
                                             ? window
                                             : (typeof process === 'object' &&
                                                typeof require === 'function' &&
                                                typeof global === 'object')
                                               ? global
                                               : this);
			3. let [x = 1] = [null]; (x=null) // 默认会匹配undefined，当null！==undefined 时，就会被赋值
			   let [x = 1] = []; (x=1)
			4. 对象解构，需注意不是深拷贝，更改某个对象属性值，原对象属性值会发生改变
			5. for of可以遍历字符串、map
			6. '123'.repeat(2)  =>  123123
			7. padStart(/*字符串总长度*/, /*指定需补的字符串*/)，padEnd()  // 字符串长度不够，自动用指定字符串补全
			8. new RegExp(/abc/ig, 'i').flags    //  指定的修饰符‘i’, 将会覆盖以前的‘ig’
			9.正则中可以利用lastIndex属性来指定从何处开始匹配  /a/.lastIndex

四、 vue
       一、vue3.0 的响应式：  proxy 不会去污染原对象
	         <script src="./dist/reactivity.global.js"></script>
             <script>
             const { reactive, effect } = VueObserver
             const origin = {
               count: 0
             }
             const state = reactive(origin)  //  利用reactive把origin用Proxy包裹
             const fn = () => {
               const count = state.count
               console.log(`set count to ${count}`)
             }
             effect(fn)  // 使用 effect() 函数把 fn() 作为响应式回调。当 state.count 发生变化时，便触发了 fn()
			             // 由于在 fn() 里面有引用到 Proxy 对象的属性，所以这一步会触发对象的 getter，从而启动依赖收集。
						 // 当一个函数fn()被effect()包裹后，就会变成一个响应式的effect函数， 而且 fn()函数也会被立即执行一次
             </script>

	   二、vue2.0的响应式：
	         1. Object.defineProperty() // 最初设计是用来给对象的属性设置权限的
			 2. Object.frezee()  //  不可写、可枚举、不可配置
			 3. Object.seal()    //   可写、可枚举、不可配置
			 4. 响应式的依赖收集发生在get里， 在set里触发视图更新
			 5. 对数组的响应式，利用装饰者模式，拷贝一份原数组方法
五、 http
     一、 XMLHttpRequest
	 二、 跨域: CROS
                JSONP

六、 安全：https://mp.weixin.qq.com/s/mI859obHtYoj9OH9jS780g
       一、常见几种攻击方式：
	       1. SQL注入：  'select * from user where id='当浏览器传一个id为true时，这就会查询所有
		   2. XSS：  XSS 全称是跨站脚本攻击。通过代码注入的方式来达到攻击的目的。例如： 输入这样的文本<script>alert(1)</script>, 有的浏览器会自动执行
		         有两种方式可以防御：
                 1. 字符转译
                 2. CSP(Content Security Policy)：  设置 HTTP Header 中的 Content-Security-Policy
		   3. CSRF： CSRF  全称是跨站请求伪造( Cross Site Request Forgery)，本质上， 说白了就是借用用户的身份或权限偷偷的完成某些操作。
                     CSRF 的发生其实是借助了 cookie 的特性。
					 我们登录了某个 http://tao.com 购物网站之后，cookie 就会有登录过的标记了。此时请求http://tao.com/pay?id=123&money=1000，
					 是会带着 cookie 的，server 端就知道已经登录了。如果在http://tao.com去请求其他域名的 API ,  例如http://tx.com/api时，
					 是不会带 cookie 的，这是浏览器同源策略的限制。但是此时在其他域名的页面中，请求http://tao.com/pay?id=123&money=1000，
					 就会带着tao.com的 cookie 。这是发生 CSRF 攻击的理论基础。
					 	 防御： 防御CSRF 有效的手段就是加入各个层级的权限验证.
                            例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者扫码验证才行。
                            除此之外，敏感的接口要使用POST请求而不是GET.

		   4. 点击劫持： 也被称为UI-覆盖攻击，攻击方式就是在某些操作的按钮上加一层透明的iframe。
		           防御方法： 1. 使用 HTTP 头防御
				                    通过配置 nginx 发送 X-Frame-Options 响应头，这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
									这样浏览器就会阻止嵌入网页的渲染。该响应头有三个值可选，分别是：
									                                                        DENY，表示页面不允许通过 iframe 的方式展示。
																							SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示。
							  2. 使用 Javascript 防御
							        判断顶层视口的域名是不是和本页面的域名一致，如果不一致就让恶意网页自动跳转到我方的网页。																ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示。
    
		   5. 中间人劫持：中间人攻击（Man-in-the-Middle Attack, MITM）
		                  简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探来达到攻击的目的，而通信的双方却毫不知情。
						  建议： 
                          以下是针对防止中间人攻击的一些建议：
                             确保当前你所访问的网站使用了HTTPS
                             如果你是一个网站管理员，你应当执行HSTS协议
                             不要在公共Wi-Fi上发送敏感数据
                             如果你的网站使用了SSL，确保你禁用了不安全的SSL/TLS协议。
                             不要点击恶意链接或电子邮件。

七、 新技术   
             1. webassembly
			 2. flutter
			 3. sticky
			 4. webp
			 5. web bundles api 离线分发web内容

八、 算法
九、 项目:   鉴权、
             首屏渲染：为了seo优化和首屏渲染速度、（纯客户端程序，需要加载各种js来渲染页面，因而不利于seo优化）
			   1.  ssr(srever side render):
			       1. 	特点： 每次访问都必须新建一个vue实例，只会触发beforeCreate和created函数， 其他就需要客户端的js
				               每次在服务端只是生成html字符串，然后在客户端触发mounted，挂载到页面上
				   2.   安装vue-server-renderer ;
				           用法： const render = require('vue-server-render').createRenderer()
						          render.renderToString(app /* vue 实例 */).then(html=> {
								  
								  })
						参考地址：https://zhuanlan.zhihu.com/p/41427873		  
				   3.  浏览器环境才能执行的函数对象，不要在服务端中运行（即不要出现在beforecreate和created函数中）	
                   4.  路由一定是采用history模式，因为hash模式的路由提交不到服务器	
                   5.  官方方案使用Vuex在服务端预获取数据。 在服务端添加vue钩子函数asyncData，获取数据后，将数据保存在vuex的store结构中，同时渲染页面4
                          例子：   asyncData ({ store }) {
                                       //惰性注册store模块
                                          store.registerModule('foo', fooStoreModule)
                                       //执行foo命名空间下名为inc的action操作
                                       return store.dispatch('foo/inc')		
                                   ｝									   
  			 打包优化、
			   1. webpack配置
			   2. dll优化： 先对loadsh、jquery这些不会改变的代码进行webpack打包处理，然后再对其他文件进行打包处理
			             1. dll单独配置（webpack.dll.js）：  import webpack from 'webpack'
                                                             module.exports = {
                                                               entry: {
                                                                 vendor: ['loadsh']
                                                               },
                                                               output: {
                                                                 path: __dirname + '/dll',
                                                                 filename: '[name].dll.js',
                                                                 library: '[name]_library'
                                                               },
                                                               plugins: [
                                                                 new webpack.DllPlugin({
                                                                   path: __dirname + '/dll/[name]-manifest.json',
                                                                   name: '[name]_library'
                                                                 })
                                                               ]
															   }
                          2. webpack配置：plugins: [
						     new webpack.DllReferencePlugin({
                                 manifest: require('../dll/vendor-manifest.json')
                           })
						  ]  
                         3. 在打包后的文件中手动引入 主页面index.html
                         4. 其他文件，正常引入，并使用		
                  3. 严格控制组件内存回收
                  4. webworker并发渲染       				 
													  
			   
			 mock、
			 发布服务：
			    nginx原理
				负载
				安全
				跨域
              问题1: 避免表单重复提交，或按钮重复点击：  1.  设置变量，带请求结束后，更新变量。 2. 自定义指令 3. 重写组件，事情变得麻烦，不可取     
			防止重复提交： （自定义指令）
                       Vue.directive("btn-control", {
                           // 插入dom 时做的事情
                           inserted: function(el, bind) {
                               el.addEventListener("click", () => {
                                   el.disabled = true;
                                   bind.value().then(res => {
                                       el.disabled = false;
                                   });
                               });
                           }	
十、 axios源码、vue-router、 vuex